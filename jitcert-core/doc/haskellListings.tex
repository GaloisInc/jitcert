\usepackage{listings}
\usepackage{amssymb}
% uncomment next line to restore colors
% \def\withcolor{}


\newsavebox\MBox
\newcommand\Cline[2][red]{{\sbox\MBox{$#2$}%
  \rlap{\usebox\MBox}\color{#1}\rule[-1.2\dp\MBox]{\wd\MBox}{0.5pt}}}

\ifdefined\withcolor
	 \definecolor{haskellblue}{rgb}{0.0, 0.0, 1.0}
	 \definecolor{haskellstr}{rgb}{0.2, 0.2, 0.6}
	 \definecolor{haskellred}{rgb}{1.0, 0.0, 0.0}
  \definecolor{gray_ulisses}{gray}{0.55}
  \definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
  \definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
  \definecolor{green_ulises}{rgb}{0.2,0.75,0}
\else
	\definecolor{haskellblue}{gray}{0.1}
	\definecolor{haskellstr}{gray}{0.1}
	\definecolor{haskellred}{gray}{0.1}
	\definecolor{gray_ulisses}{gray}{0.1}
	\definecolor{castanho_ulisses}{gray}{0.1}
	\definecolor{preto_ulisses}{gray}{0.1}
	\definecolor{green_ulisses}{gray}{0.1}
\fi

% RJ: I don't like the colors. Too confusing.
%
% \definecolor{lcolor}{rgb}{0.0, 0.0, 1.0}
% \definecolor{lappcolor}{rgb}{1.0, 0.0, 0.0}
% \definecolor{lappascolor}{rgb}{0.0, 1.0, 0.0}

\definecolor{lcolor}{gray}{0.0}
\definecolor{lappcolor}{gray}{0.0}
\definecolor{lappascolor}{gray}{0.0}

\def\codesize{\small}

\definecolor{usercolor}{RGB}{47, 46, 51}
\definecolor{liocolor}{RGB}{10, 55, 104}
\definecolor{yesodcolor}{RGB}{11, 104, 51}
\definecolor{dbcolor}{RGB}{47, 46, 51}

% \newcommand\showfocus[1]{\color{red}{#1}}
\newcommand\showyesod[1]{\color{yesodcolor}{#1}}
\newcommand\showlio[1]{\color{liocolor}{#1}}
% \newcommand\showfocus[1]{\underbar{#1}}
% \newcommand\showfocus[1]{\color{purple}{\textbf{#1}}}

\lstdefinelanguage{HaskellUlisses} {
	basicstyle=\ttfamily\small,
	moredelim=[is][\showyesod]{\*}{\*},
	moredelim=[is][\showlio]{\^}{\^},
	sensitive=true,
	%% morecomment=[l][\color{gray_ulisses}\ttfamily\itshape\codesize]{--},
	%% morecomment=[s][\color{gray_ulisses}\ttfamily\itshape\codesize]{-}{-},
	morecomment=[l][\color{gray_ulisses}\ttfamily\itshape\codesize]{--},
	morestring=[b]",
	stringstyle=\color{haskellstr},
	basewidth={0.53em},
	showstringspaces=false,
	numberstyle=\codesize,
	numberblanklines=true,
	showspaces=false,
	breaklines=true,
	showtabs=false,
  %% whitespace hackery
  %% lineskip= -2pt,
  %% aboveskip=1pt,
  %% belowskip=1pt,
  literate={ {quals}{{$\mathbb{Q}$}}1
             {iquals}{{$\mathbb{Q}$}}2
             {ltsolzero}{{$A_0$}}2
             {band}{{$\textbf{\texttt{and}}$}}2
             {->}{{$\rightarrow$}}2
             {lambda}{{$\lambda$}}2
             {<-}{{$\leftarrow$}}1
             {monotonic}{{monotonic}}9
             % {not}{{$\neg\!\!\!$}}2
             {===}{{$\equiv$}}2
             {ς}{{$\varsigma$}}1
             {ε}{{$\epsilon$}}1
             {φ}{{$\phi$}}1
             {canFlowTo}{{$\sqsubseteq$}}1
             {cannotFlowTo}{{$\not\sqsubseteq$}}1
%             {&&}{{$\land$}}1
             {meet}{{$\sqcap$}}1
             {jjoin}{{join}}4
             {join}{{$\sqcup$}}1
             {bot}{{$\perp$}}1
             {top}{{$\top$}}1
             {=>}{{$\Rightarrow$}}1
             {<=>}{{$\Leftrightarrow$}}1
             {GType}{{\tilde{\mathit{\texttt{Type}}}}}4
           },
	emph=
	{[1]
		FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
		asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
		const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
		dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
		error,even,exp,exponent,fail,mapMaybe,filter,flip,floatDigits,floatRadix,floatRange,floor,
		fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
		fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
		interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
		isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
		last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
		maxBound,posMax,negMax,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
		or,ord,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
		quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
		readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
		round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
		showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
		sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
		toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
		unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse,empty,for,initTo,
        assert,compose,checkGE,maxEvens,empty,create,get,set,initialize,idVec,fastFib,fibMemo,
        ex1,ex2,ex3,incr,inc,dec,isPos,positives,find,insert,len,size,union,fromList,initUpto,trim,
        insertSort,decsort,qsort,reverse,append,upperCase, ifM, whileM, get, decrM, diff,
        project, select, leq, elts, keys, dkeys, dfun, addKey, pTrue, emptyRD, rFalse,
        	dom, rng, isI, isD, isS, movie1, movie2,  toI, toS, toD, good_titles, runState, ret,
        	update, getCtr, setCtr, ctr, rdCtr, wrCtr, ifTest, whileTest, posCtr, zeroCtr, decr, decCtr,
        	pread , pwrite , plookup , pcontents, pcreateF , pcreateFP, pcreateD, active, caps, pset, eqP,
        	write, contents, alloc, derivP, copyP, createDir, store, copyRec, copySpec,
        	forM_, when, flookup, fread, createDir, pcreateFile, isFile, copyFrame, ?
	},
	emphstyle={[1]\color{haskellblue}},
	emph=
	{[2] Eq, Program, Label, 
	},
	emphstyle={[2]\color{castanho_ulisses}},
	emph=
	{[3]
		case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
		module,of,primitive,then,refinement,type,where,forall,bound,and,
		% otherwise,
		measure,reflect,predicate, assume, return
	},
	emphstyle={[3]\color{preto_ulisses}\textbf},
	emph=
	{[4]
		quot,rem,div,mod,elem,notElem,seq
	},
	emphstyle={[4]\color{castanho_ulisses}\textbf},
	emph=
	{[5]
		EQ,GT,LT,Left,Right
		%, False, True, Just, Nothing
	},
	emphstyle={[5]\color{preto_ulisses}\textbf},
	emph=
	{[6]
	    axiomatize, measure, inline, return
	},
	emphstyle={[6]\color{lcolor}}
}

%%%ORIG
%%%\lstnewenvironment{code}
%%%{\textbf{Haskell Code} \hspace{1cm} \hrulefill \lstset{language=HaskellUlisses}}
%%%{\hrule\smallskip}

%V1
%\lstnewenvironment{code}
%{\smallskip \lstset{language=HaskellUlisses}}
%{\smallskip}

\lstnewenvironment{code}
{\lstset{language=HaskellUlisses}}
{}

\lstnewenvironment{mcode}
{\lstset{language=HaskellUlisses,columns=fullflexible,keepspaces,mathescape}}
{}

\lstMakeShortInline[language=HaskellUlisses,mathescape,keepspaces,mathescape,basicstyle=\ttfamily\small,breakatwhitespace]@


\lstdefinelanguage{Pseudo} {
	basicstyle=\ttfamily\codesize,
	sensitive=true,
  mathescape=true,
	morecomment=[l][\color{gray_ulisses}\ttfamily\codesize]{--},
	morecomment=[s][\color{gray_ulisses}\ttfamily\codesize]{\{-}{-\}},
	morestring=[b]",
	showstringspaces=false,
	numberstyle=\codesize,
	numberblanklines=true,
	showspaces=false,
	breaklines=true,
	showtabs=false
}
